<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Multi-Voice Text-to-Speech</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 1.5em; background: #f5f5f5; color: #222; }
  .block { background: white; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); padding: 1em; margin-bottom: 1em; }
  textarea { width: 100%; min-height: 80px; padding: .5em; font-size: 15px; border: 1px solid #ccc; border-radius: 6px; }
  button { margin: .3em; padding: .5em 1em; border-radius: 6px; border: none; background: #0078d7; color: white; cursor: pointer; }
  button:hover { background: #005fa3; }
  select { padding: .3em; font-size: 14px; border-radius: 6px; }
  #output { margin-top: 1em; padding: 1em; background: #fff; border-radius: 8px; font-family: monospace; white-space: pre-wrap; }
  #progressBar { width: 100%; height: 14px; display:none; margin-top:.5em; }
</style>
</head>
<body>
  <h1>üéôÔ∏è Multi-Voice Text-to-Speech</h1>
  <div id="container"></div>

  <div style="margin-top:1em;">
    <button onclick="addBlock()">‚ûï Add Block</button>
    <button onclick="speakAll()">‚ñ∂Ô∏è Speak All</button>
    <button onclick="stopAll()">‚èπÔ∏è Stop</button>
	<button onclick="exportScript()">üìù Export Script</button>
    <button onclick="exportAllMp3()">üéß Export All to MP3</button>
  </div>

  <div id="output">Ready.</div>
  <progress id="progressBar" value="0" max="100"></progress>

<script>
let voices = {};
let stopRequested = false;
let activeAudios = [];
let activeControllers = []; // üëà New: for fetch abortion

// Output helper
function output(msg) {
  const el = document.getElementById("output");
  el.textContent = msg;
  console.log(msg);
}

// Load voices from server
async function loadVoices() {
  try {
    const res = await fetch("/voices");
    const data = await res.json();
    const grouped = {};
    for (const v of data) {
      const prefix = v.split("-")[0];
      grouped[prefix] ||= [];
      grouped[prefix].push(v);
    }
    voices = grouped;
  } catch (e) {
    console.error("Failed to load voices:", e);
    voices = { en: ["en-US-AriaNeural", "en-US-GuyNeural"] };
  }
}

// ‚úÖ Initialize safely after DOM is ready
async function init() {
  await loadVoices();
  addBlock();
  output("‚úÖ Voices loaded. Ready.");
}
window.addEventListener("DOMContentLoaded", init);

// Add a new block
function addBlock(text = "", voice = "en-US-AriaNeural") {
  const div = document.createElement("div");
  div.className = "block";
  div.innerHTML = `
    <label>Lang:</label>
    <select class="langSelect"></select>
    <label>Voice:</label>
    <select class="voiceSelect"></select>
    <button class="speakBtn" onclick="speakBlock(this)">‚ñ∂Ô∏è Speak</button>
    <button onclick="exportBlock(this)">üíæ To MP3</button>
	<button onclick="removeBlock(this)">üóëÔ∏è Remove</button>
    <textarea placeholder="Enter text...">${text}</textarea>
  `;
  document.getElementById("container").appendChild(div);
  fillLangDropdown(div.querySelector(".langSelect"), div.querySelector(".voiceSelect"), voice);
}

// ----------------------------------------------
// üóëÔ∏è Remove a block
// ----------------------------------------------
function removeBlock(btn) {
  const block = btn.parentElement;
  block.remove();
  output("üóëÔ∏è Block removed.");
}


// Fill dropdowns
function fillLangDropdown(langSelect, voiceSelect, selectedVoice) {
  langSelect.innerHTML = "";
  for (const lang of Object.keys(voices).sort()) {
    const opt = document.createElement("option");
    opt.value = lang;
    opt.textContent = lang;
    langSelect.appendChild(opt);
  }
  langSelect.value = selectedVoice.split("-")[0] || Object.keys(voices)[0];
  fillVoiceDropdown(langSelect, voiceSelect, selectedVoice);
  langSelect.addEventListener("change", () => fillVoiceDropdown(langSelect, voiceSelect));
}

function fillVoiceDropdown(langSelect, voiceSelect, selectedVoice) {
  const lang = langSelect.value;
  const list = voices[lang] || [];
  voiceSelect.innerHTML = "";
  for (const v of list) {
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    voiceSelect.appendChild(opt);
  }
  if (selectedVoice) voiceSelect.value = selectedVoice;
}

// Parse tags like [voice id]: or [pause n]
function parseSegments(text, defaultVoice) {
  const regex =
    /\[voice\s+([^\]]+)\]\s*:\s*([^\[]*)|\[pause\s*(\d+(?:\.\d+)?)\s*(?:s|sec|seconds)?\]/gi;
  const segments = [];
  let last = 0,
    match;
  while ((match = regex.exec(text))) {
    if (match.index > last) {
      const between = text.slice(last, match.index).trim();
      if (between) segments.push({ type: "text", content: between });
    }
    if (match[1]) {
      segments.push({ type: "voice", name: match[1].trim() });
      const inlineText = (match[2] || "").trim();
      if (inlineText) segments.push({ type: "text", content: inlineText });
    } else if (match[3]) {
      segments.push({ type: "pause", duration: parseFloat(match[3]) });
    }
    last = regex.lastIndex;
  }
  const tail = text.slice(last).trim();
  if (tail) segments.push({ type: "text", content: tail });
  return segments;
}

// ----------------------------------------------
// Core speaking logic shared by both functions
// ----------------------------------------------
async function speakSegments(segments, initialVoice) {
  let currentVoice = initialVoice;
  let nextPromise = null;
  let i = 0;

  async function generateAudio(seg, voice) {
    if (stopRequested) return null;
    if (seg.type === "pause") {
      await new Promise(r => setTimeout(r, seg.duration * 1000));
      return null;
    }
    if (seg.type === "voice") return { type: "voice", name: seg.name };
    if (seg.type === "text") {
      const text = seg.content.trim();
      if (!text) return null;

      // üëá Create abortable fetch
      const controller = new AbortController();
      activeControllers.push(controller);

      try {
        const res = await fetch("/tts", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text, voice }),
          signal: controller.signal
        });
        if (!res.ok) return null;
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        return { type: "audio", audio, voice, url };
      } catch (err) {
        if (err.name === "AbortError") {
          console.log("‚èπÔ∏è Fetch aborted:", text);
          return null;
        }
        console.error("Fetch failed:", err);
        return null;
      } finally {
        activeControllers = activeControllers.filter(c => c !== controller);
      }
    }
    return null;
  }

  while (i < segments.length && (!nextPromise || (await nextPromise) === null))
    nextPromise = generateAudio(segments[i++], currentVoice);

  while (true) {
    if (stopRequested) break;
    if (!nextPromise) break;
    const current = await nextPromise;
    nextPromise = null;

    if (!current) {
      if (i >= segments.length) break;
      nextPromise = generateAudio(segments[i++], currentVoice);
      continue;
    }

    if (current.type === "voice") {
      currentVoice = current.name;
      output("üéôÔ∏è Voice change ‚Üí " + currentVoice);
      if (i < segments.length)
        nextPromise = generateAudio(segments[i++], currentVoice);
      continue;
    }

    if (current.type === "audio") {
      output("üîä Speaking (" + current.voice + ")");
      const url = current.url;
      activeAudios.push(current.audio);
      const playPromise = new Promise(resolve => {
        current.audio.onended = () => {
          try { URL.revokeObjectURL(url); } catch {}
          activeAudios = activeAudios.filter(a => a !== current.audio);
          resolve();
        };
        current.audio.onerror = () => {
          try { URL.revokeObjectURL(url); } catch {}
          activeAudios = activeAudios.filter(a => a !== current.audio);
          resolve();
        };
        current.audio.play();
      });
      if (i < segments.length)
        nextPromise = generateAudio(segments[i++], currentVoice);
      else nextPromise = null;
      await playPromise;
    }
  }
  nextPromise = null;
}

// ----------------------------------------------
// ‚ñ∂Ô∏è Speak single block
// ----------------------------------------------
async function speakBlock(btn) {
  const block = btn.parentElement;
  const text = block.querySelector("textarea").value.trim();
  if (!text) return alert("Please enter text.");
  stopRequested = false;
  const voice = block.querySelector(".voiceSelect").value;
  const segments = parseSegments(text, voice);
  await speakSegments(segments, voice);
  output(stopRequested ? "‚èπÔ∏è Stopped." : "‚úÖ Finished block.");
}

// ----------------------------------------------
// ‚ñ∂Ô∏è Speak all blocks sequentially with voice tags
// ----------------------------------------------
async function speakAll() {
  const blocks = [...document.querySelectorAll(".block")];
  if (!blocks.length) return alert("No blocks to speak.");
  stopRequested = false;
  output("üé¨ Starting multi-block playback...");

  for (let i = 0; i < blocks.length; i++) {
    if (stopRequested) break;
    const block = blocks[i];
    const text = block.querySelector("textarea").value.trim();
    if (!text) continue;
    const voice = block.querySelector(".voiceSelect").value;
    const segments = parseSegments(text, voice);
    output(`üéß Block ${i + 1}/${blocks.length}`);
    await speakSegments(segments, voice);
  }

  output(stopRequested ? "‚èπÔ∏è Stopped." : "‚úÖ Finished all blocks.");
}

// ----------------------------------------------
// üíæ Export single block
// ----------------------------------------------
async function exportBlock(btn) {
  const block = btn.parentElement;
  const text = block.querySelector("textarea").value.trim();
  const voice = block.querySelector(".voiceSelect").value;
  if (!text) return alert("No text.");
  output(`üéß Generating MP3 for ${voice}...`);
  const res = await fetch("/tts", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text, voice })
  });
  if (!res.ok) return alert("Error generating audio.");
  const blob = await res.blob();
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `${voice}.mp3`;
  a.click();
  try { URL.revokeObjectURL(a.href); } catch {}
  output(`üíæ Downloaded ${voice}.mp3`);
}

// ----------------------------------------------
// üéß Export all blocks to MP3
// ----------------------------------------------
async function exportAllMp3() {
  const blocks = [...document.querySelectorAll(".block")].map(b => ({
    text: b.querySelector("textarea").value.trim(),
    voice: b.querySelector(".voiceSelect").value
  })).filter(b => b.text);
  if (!blocks.length) return alert("No blocks to export.");

  output("üîÅ Starting combined MP3 export...");
  const bar = document.getElementById("progressBar");
  bar.style.display = "block";
  bar.value = 0;

  const startRes = await fetch("/tts-all", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ blocks })
  });
  if (!startRes.ok) { bar.style.display = "none"; return alert("Failed to start export."); }
  const startData = await startRes.json();
  const jobId = startData.job_id;
  const downloadPath = startData.download;

  let done = false;
  while (!done) {
    await new Promise(r => setTimeout(r, 1500));
    try {
      const p = await fetch(`/progress/${jobId}`).then(r => r.json());
      if (p.error) { output("Export error"); break; }
      output(`${p.progress}% ‚Äî ${p.status}`);
      bar.value = p.progress;
      if (p.status === "Complete" || p.progress >= 100) done = true;
    } catch (err) { console.error("progress poll error:", err); break; }
  }

  if (done) {
    window.location.href = downloadPath;
    output("‚úÖ Combined MP3 download started.");
  } else output("‚ö†Ô∏è Export did not complete successfully.");
  bar.style.display = "none";
}

// ----------------------------------------------
// üìù Export all text blocks to TXT file
// ----------------------------------------------
function exportScript() {
  const blocks = [...document.querySelectorAll(".block")];
  if (!blocks.length) return alert("No blocks to export.");

  const parts = blocks.map(b => {
    const text = b.querySelector("textarea").value.trim();
    const voice = b.querySelector(".voiceSelect").value;
    if (!text) return "";

    // Add [voice id] tag if missing
    if (!/\[voice\s+[^\]]+\]/i.test(text)) {
      return `[voice ${voice}]:\n${text}`;
    }
    return text;
  }).filter(t => t);

  if (!parts.length) return alert("No text found.");

  const content = parts.join("\n\n");
  const blob = new Blob([content], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "script.txt";
  a.click();
  try { URL.revokeObjectURL(a.href); } catch {}
  output("üìù Script exported to script.txt");
}


// ----------------------------------------------
// ‚èπÔ∏è Stop everything immediately
// ----------------------------------------------
function stopAll() {
  stopRequested = true;
  // Abort all active fetches
  activeControllers.forEach(c => { try { c.abort(); } catch {} });
  activeControllers = [];
  // Stop all playing audio
  activeAudios.forEach(a => { try { a.pause(); a.currentTime = 0; } catch {} });
  activeAudios = [];
  output("‚èπÔ∏è Force-stopped all generation and playback.");
}
</script>


</body>
</html>
